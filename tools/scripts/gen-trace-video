#!/usr/bin/env python3

import numpy
import math
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import argparse
import re

def parse_arguments():
    parser = argparse.ArgumentParser(
        description='Generate a video of how a FANN network evolves')
    parser.add_argument(
        '-t', '--train-file', dest='file_train', type=str, required=True,
        help='The FANN training file')
    parser.add_argument(
        '-l', '--log-file', dest='file_log', type=str,
        nargs='+',
        help='The log of outputs generated by fann-train or fann-batch')
    parser.add_argument(
        '--labels', dest='labels', type=str,
        nargs='+',
        help='Labels to use for the graph')
    parser.add_argument(
        '-s', '--save-video', dest='file_save', type=str,
        help='The file to save the video in')
    parser.add_argument(
        '-x', '--x-limits', dest='xLimits', type=float, default=[-1,1],
        nargs=2,
        help='The domain of the plot (X axis)')
    parser.add_argument(
        '-y', '--y-limits', dest='yLimits', type=float, default=[-1,1],
        nargs=2,
        help='The range of the plot (Y axis)')
    return parser.parse_args()

def file_len(filename):
    with open(filename) as f:
        for i, l in enumerate(f):
            pass
    return i+1

def main():
    args = parse_arguments()
    re_num = re.compile('[-.e\d]+')
    re_header = re.compile('(\d+) (\d+) (\d+)')

    with open(args.file_train, 'r') as f:
        line = f.readline()
        m = re_header.match(line)
        num_items = int(m.group(1))
        num_inputs = int(m.group(2))
        num_outputs = int(m.group(3))
        inputs = numpy.zeros((num_items, num_inputs))
        outputs_correct = numpy.zeros((num_items, num_outputs))
        for i in range(num_items):
            line = f.readline()
            m = re_num.findall(line)
            for x in range(len(m)):
                inputs[i][x] = float(m[x])
            line = f.readline()
            m = re_num.findall(line)
            for x in range(len(m)):
                outputs_correct[i][x] = float(m[x])

    num_batches = int(file_len(args.file_log[0]) / num_items / num_outputs)

    print(args.file_log)
    num_logs = len(args.file_log)
    outputs = numpy.zeros((num_logs, num_batches, num_items, num_outputs))

    for log in range(num_logs):
        with open(args.file_log[log], 'r') as f:
            for batch in range(num_batches):
                for item in range(num_items):
                    line = f.readline()
                    m = re_num.findall(line)
                    for output in range(len(m)):
                        outputs[log][batch][item][output] = float(m[output])

    fig = plt.figure()
    ax = plt.axes(xlim=(args.xLimits[0], args.xLimits[1]),
                  ylim=(args.yLimits[0], args.yLimits[1]))

    line_nn = [ax.plot(0, 0) for i in range(num_logs)]

    x, y_correct = zip(*sorted(zip(inputs, outputs_correct)))
    line_orig, = ax.plot(x, y_correct)
    line_orig.set_label('Correct')

    for log in range(num_logs):
        x, y = zip(*sorted(zip(inputs, outputs[log][0])))
        line_nn[log], = ax.plot(x, y, '.')
        if args.labels is not None:
            line_nn[log].set_label(args.labels[log])
        else:
            line_nn[log].set_label(args.file_log[log])
    plt.legend(loc='best')

    def update(i):
        for log in range(num_logs):
            x, y = zip(*sorted(zip(inputs, outputs[log][i])))
            line_nn[log].set_data(x, y)
        plt.title("Epoch {0}".format(i))
        return line_nn,

    def init():
        for log in range(num_logs):
            line_nn[log].set_data([], [])
        return line_nn,

    ani = animation.FuncAnimation(fig, update, init_func=init,
                                  frames=len(outputs[0]), interval=1)
    if (args.file_save is not None):
        ani.save(args.file_save, fps=30, extra_args=['-vcodec', 'libx264'])
    else:
        plt.show()

if __name__ == '__main__':
    main()
